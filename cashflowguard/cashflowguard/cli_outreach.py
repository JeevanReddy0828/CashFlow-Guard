"""
New CLI commands for outreach, scheduling, and tracking.

Adds to existing cashflowguard CLI:
- outreach: Generate messages for specific invoices
- schedule: Manage follow-up schedules
- track: Log and view actions
- metrics: View success metrics
"""

import typer
from rich.console import Console
from rich.table import Table
from rich import print as rprint
from pathlib import Path
from datetime import datetime, timedelta
import pandas as pd

# These would be added to the main cli.py file

app = typer.Typer()
console = Console()


@app.command()
def outreach(
    data_dir: str = typer.Option(..., help="Directory with data files"),
    invoice_id: str = typer.Option(None, help="Specific invoice ID"),
    top: int = typer.Option(10, help="Top N invoices to generate messages for"),
    action_type: str = typer.Option("friendly_reminder", help="Type of message"),
    output: str = typer.Option("messages.csv", help="Output file for generated messages"),
    company_name: str = typer.Option("Your Company", help="Company name"),
    send_mode: bool = typer.Option(False, help="Actually send messages (requires email config)")
):
    """
    Generate personalized collection messages.
    
    Example:
        cashflowguard outreach --data-dir data/uci --top 20 --action-type second_notice
    """
    from cashflowguard.core.loader import DataLoader
    from cashflowguard.ml.predict import score_invoices
    
    # Import new modules
    import sys
    sys.path.append(str(Path(__file__).parent))
    from message_generator import MessageGenerator
    from action_logger import ActionLogger
    
    console.print("\n[bold blue]Generating Collection Messages...[/bold blue]\n")
    
    # Load data
    loader = DataLoader(data_dir)
    customers_df, invoices_df, payments_df, _ = loader.load_all()
    
    # Score invoices
    model_path = Path("models") / "model_gradient_boost.pkl"
    if model_path.exists():
        scored_df = score_invoices(invoices_df, customers_df, payments_df, model_path)
    else:
        scored_df = invoices_df.copy()
        scored_df["risk_score"] = 50  # Default
        scored_df["risk_category"] = "medium"
    
    # Filter to specific invoice or top N
    if invoice_id:
        target_invoices = scored_df[scored_df["invoice_id"] == invoice_id]
    else:
        target_invoices = scored_df[scored_df["status"] == "open"].nlargest(top, "risk_score")
    
    # Generate messages
    msg_gen = MessageGenerator(company_name=company_name)
    logger = ActionLogger()
    
    messages = []
    
    for _, invoice in target_invoices.iterrows():
        # Get customer info
        customer = customers_df[customers_df["customer_id"] == invoice["customer_id"]].iloc[0]
        
        # Calculate days overdue
        due_date = pd.to_datetime(invoice["due_date"])
        days_overdue = max(0, (datetime.now() - due_date).days)
        
        # Generate email
        email = msg_gen.generate_email(
            customer_name=customer.get("name", invoice["customer_id"]),
            invoice_id=invoice["invoice_id"],
            invoice_amount=invoice["invoice_amount"],
            due_date=due_date,
            days_overdue=days_overdue,
            action_type=action_type,
            risk_level=invoice.get("risk_category", "medium")
        )
        
        # Generate SMS
        sms = msg_gen.generate_sms(
            customer_name=customer.get("name", invoice["customer_id"]),
            invoice_id=invoice["invoice_id"],
            invoice_amount=invoice["invoice_amount"],
            days_overdue=days_overdue,
            action_type=action_type
        )
        
        messages.append({
            "invoice_id": invoice["invoice_id"],
            "customer_id": invoice["customer_id"],
            "customer_name": customer.get("name", ""),
            "customer_email": customer.get("email", ""),
            "invoice_amount": invoice["invoice_amount"],
            "days_overdue": days_overdue,
            "risk_score": invoice.get("risk_score", 0),
            "action_type": action_type,
            "email_subject": email["subject"],
            "email_body": email["body"],
            "sms_text": sms
        })
        
        # Log action if in send mode
        if send_mode:
            logger.log_action(
                invoice_id=invoice["invoice_id"],
                customer_id=invoice["customer_id"],
                action_type=action_type,
                channel="email",
                message_sent=email["body"],
                notes=f"Generated by CLI - Risk: {invoice.get('risk_category', 'unknown')}"
            )
    
    # Save to CSV
    messages_df = pd.DataFrame(messages)
    messages_df.to_csv(output, index=False)
    
    # Display summary
    table = Table(title=f"Generated {len(messages)} Messages")
    table.add_column("Invoice ID", style="cyan")
    table.add_column("Customer", style="green")
    table.add_column("Amount", justify="right", style="yellow")
    table.add_column("Days Overdue", justify="right", style="red")
    table.add_column("Action Type", style="magenta")
    
    for msg in messages[:10]:  # Show first 10
        table.add_row(
            msg["invoice_id"],
            msg["customer_name"][:30],
            f"${msg['invoice_amount']:,.2f}",
            str(msg["days_overdue"]),
            msg["action_type"]
        )
    
    console.print(table)
    console.print(f"\nâœ“ Messages saved to [bold]{output}[/bold]")
    
    if send_mode:
        console.print(f"âœ“ Actions logged to database")
    else:
        console.print("\n[yellow]NOTE: Add --send-mode to actually send and log messages[/yellow]")


@app.command()
def schedule(
    data_dir: str = typer.Option(..., help="Directory with data files"),
    output: str = typer.Option("schedule.csv", help="Output file for schedule"),
    max_attempts: int = typer.Option(None, help="Max follow-up attempts per invoice"),
    view_only: bool = typer.Option(False, help="View existing schedule only")
):
    """
    Generate or view collections follow-up schedule.
    
    Example:
        cashflowguard schedule --data-dir data/uci --max-attempts 5
    """
    from cashflowguard.core.loader import DataLoader
    from cashflowguard.ml.predict import score_invoices
    
    import sys
    sys.path.append(str(Path(__file__).parent))
    from collections_scheduler import CollectionsScheduler
    
    console.print("\n[bold blue]Collections Schedule[/bold blue]\n")
    
    scheduler = CollectionsScheduler(business_days_only=True)
    
    if view_only and Path(output).exists():
        # Load and display existing schedule
        schedule_df = pd.read_csv(output)
        schedule_df["scheduled_date"] = pd.to_datetime(schedule_df["scheduled_date"])
        
        # This week's actions
        weekly = scheduler.get_this_weeks_actions(schedule_df)
        
        table = Table(title="This Week's Collections Actions")
        table.add_column("Date", style="cyan")
        table.add_column("Invoice", style="green")
        table.add_column("Customer", style="yellow")
        table.add_column("Action", style="magenta")
        table.add_column("Attempt", justify="right")
        
        for _, action in weekly.head(20).iterrows():
            table.add_row(
                action["scheduled_date"].strftime("%m/%d"),
                action["invoice_id"],
                action["customer_id"][:15],
                action["action_type"],
                str(action["attempt_number"])
            )
        
        console.print(table)
        console.print(f"\nðŸ“… Total actions this week: {len(weekly)}")
        return
    
    # Generate new schedule
    loader = DataLoader(data_dir)
    customers_df, invoices_df, payments_df, _ = loader.load_all()
    
    # Score invoices
    model_path = Path("models") / "model_gradient_boost.pkl"
    if model_path.exists():
        scored_df = score_invoices(invoices_df, customers_df, payments_df, model_path)
    else:
        scored_df = invoices_df.copy()
        scored_df["risk_category"] = "medium"
    
    # Generate schedules for all open invoices
    all_schedules = []
    
    for _, invoice in scored_df[scored_df["status"] == "open"].iterrows():
        due_date = pd.to_datetime(invoice["due_date"])
        days_overdue = max(0, (datetime.now() - due_date).days)
        
        schedule = scheduler.generate_schedule(
            invoice_id=invoice["invoice_id"],
            customer_id=invoice["customer_id"],
            risk_level=invoice.get("risk_category", "medium"),
            days_overdue=days_overdue,
            max_attempts=max_attempts
        )
        
        all_schedules.extend(schedule)
    
    # Save schedule
    schedule_df = pd.DataFrame(all_schedules)
    schedule_df.to_csv(output, index=False)
    
    # Summary
    console.print(f"âœ“ Generated schedule for {len(scored_df[scored_df['status'] == 'open'])} invoices")
    console.print(f"âœ“ Total scheduled actions: {len(all_schedules)}")
    console.print(f"âœ“ Schedule saved to [bold]{output}[/bold]")
    
    # This week preview
    weekly = scheduler.get_this_weeks_actions(schedule_df)
    console.print(f"\nðŸ“… Actions scheduled this week: {len(weekly)}")


@app.command()
def track(
    action: str = typer.Argument(None, help="Action: log, view, or export"),
    invoice_id: str = typer.Option(None, help="Invoice ID to view"),
    customer_id: str = typer.Option(None, help="Customer ID to view"),
    output: str = typer.Option("audit_log.csv", help="Export filename")
):
    """
    Track and log collections actions.
    
    Examples:
        cashflowguard track view --invoice-id INV001
        cashflowguard track export --output audit.csv
    """
    import sys
    sys.path.append(str(Path(__file__).parent))
    from action_logger import ActionLogger
    
    logger = ActionLogger()
    
    if action == "view":
        if invoice_id:
            history = logger.get_invoice_history(invoice_id)
            
            table = Table(title=f"Action History: {invoice_id}")
            table.add_column("Date", style="cyan")
            table.add_column("Action", style="green")
            table.add_column("Channel", style="yellow")
            table.add_column("Response", style="magenta")
            table.add_column("Outcome", style="blue")
            
            for _, row in history.iterrows():
                table.add_row(
                    str(row.get("action_date", ""))[:10],
                    row.get("action_type", ""),
                    row.get("channel", ""),
                    row.get("response_type", "") or "-",
                    row.get("outcome_type", "") or "-"
                )
            
            console.print(table)
            
        elif customer_id:
            history = logger.get_customer_history(customer_id)
            console.print(f"\n[bold]Customer History: {customer_id}[/bold]")
            console.print(history.to_string())
        else:
            console.print("[red]Provide --invoice-id or --customer-id[/red]")
    
    elif action == "export":
        logger.export_audit_log(output)
        console.print(f"âœ“ Audit log exported to [bold]{output}[/bold]")
    
    else:
        console.print("[red]Action must be: view or export[/red]")


@app.command()
def metrics(
    days: int = typer.Option(30, help="Last N days to analyze"),
    action_type: str = typer.Option(None, help="Filter by action type"),
    export: str = typer.Option(None, help="Export to CSV")
):
    """
    View collections success metrics.
    
    Example:
        cashflowguard metrics --days 90 --action-type friendly_reminder
    """
    import sys
    sys.path.append(str(Path(__file__).parent))
    from action_logger import ActionLogger
    
    logger = ActionLogger()
    
    start_date = datetime.now() - timedelta(days=days)
    
    # Calculate metrics
    metrics = logger.calculate_success_metrics(
        start_date=start_date,
        action_type=action_type
    )
    
    # Display
    console.print(f"\n[bold blue]Collections Metrics (Last {days} Days)[/bold blue]\n")
    
    table = Table(show_header=False)
    table.add_column("Metric", style="cyan")
    table.add_column("Value", justify="right", style="green")
    
    table.add_row("Total Actions", f"{metrics['total_actions']:,}")
    table.add_row("Successful Actions", f"{metrics['successful_actions']:,}")
    table.add_row("Success Rate", f"{metrics['success_rate']:.1%}")
    table.add_row("Response Rate", f"{metrics['response_rate']:.1%}")
    table.add_row("Avg Days to Payment", f"{metrics['avg_days_to_payment']:.1f}")
    table.add_row("Total Collected", f"${metrics['total_amount_collected']:,.2f}")
    
    console.print(table)
    
    # Effectiveness by action type
    console.print("\n[bold]Effectiveness by Action Type[/bold]\n")
    effectiveness = logger.get_action_effectiveness_report()
    console.print(effectiveness.to_string(index=False))
    
    if export:
        effectiveness.to_csv(export, index=False)
        console.print(f"\nâœ“ Metrics exported to [bold]{export}[/bold]")


if __name__ == "__main__":
    app()